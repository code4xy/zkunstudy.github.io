<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="K">


    <meta name="subtitle" content="kunstudy">


    <meta name="description" content="kunstudy">


    <meta name="keywords" content="kunstudy">


<title>重难点解析系列02 | kunstudy</title>



    <link rel="icon" href="/%E6%B2%99%E6%BB%A9_%E5%A4%AA%E9%98%B3.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Zk&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Zk&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">重难点解析系列02</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">K</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 19, 2021&nbsp;&nbsp;9:23:32</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/">重难点解析系列</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="【重难点解析系列02】"><a href="#【重难点解析系列02】" class="headerlink" title="【重难点解析系列02】"></a>【重难点解析系列02】</h2><h3 id="AQS："><a href="#AQS：" class="headerlink" title="AQS："></a>AQS：</h3><p>AbstractQueuedSynchronizer（AQS）！类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p>
<p>具体框架如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.e1tq2wx84og.png" alt="image"></p>
<p>这个队列的作用就是在多线程环境下，当没有抢到锁的线程而造成阻塞，放置的阻塞队列。</p>
<p>其中volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p>
<p>对于state（资源）可以表示为锁的状态。</p>
<p>对state的操作有三种方式：</p>
<ul>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()</li>
</ul>
<p>AQS定义两种资源共享方式（说白了就是获取到锁后能干嘛）：Exclusive（独占，只有一个线程执行）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>
<p>自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>　　再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>　　一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p>查看AQS的源码，里面封装了一个Node结点，这是对每一个等待获取资源的线程的封装。里面包含了需要同步的线程本身及其等待状态如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.33fqgks5ig40.png" alt="image" style="zoom:80%;" />

<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p><strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
<p><strong>源码分析：</strong></p>
<p>直接从ReentrantLock.lock();开始分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.5aqo5uzltb8.png" alt="image"></p>
<p>lock（）接口的实现有公平锁和非公平锁。</p>
<p>里面实际执行的方法是：acquire(1);</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.2pts0gd0ipc0.png" alt="image"></p>
<p>具体的实现如下所示：（重点来了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.38n0hk5pksg0.png" alt="image"></p>
<p>先说下该函数的流程：</p>
<ol>
<li>tryAcquire()尝试直接去获取资源，如果成功则直接返回</li>
<li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<p>具体分析如下：</p>
<p>1.tryAcquire()函数的源码，并没有直接实现，具体的实现如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.bi2260vl43s.png" alt="image"></p>
<p>设计成这样，是因为AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现。</p>
<p>AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p>
<p>　　这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p>
<p>以非公平锁的实现为例：</p>
<img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.3kzktrtfedu0.png" alt="image" style="zoom:80%;" />

<p>主要就是利用了CAS原则，和volatile 修饰的关键字，来实现的获取锁。</p>
<ol start="2">
<li>addWaiter(Node)：此方法主要将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.3clsb4772vs0.png" alt="image" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.6oszf72w17g0.png" alt="image" style="zoom:80%;" />

<ol start="3">
<li>acquireQueued(Node, int)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.5n7lgose4zg0.png" alt="image"></p>
<p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了，然后进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.1w5jimemby80.png" alt="image"></p>
<p>acquireQueued()，总结下该函数的具体流程：</p>
<ol>
<li>结点进入队尾后，检查状态，找到安全休息点；</li>
<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>
</ol>
<p>分析完毕，流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.54m1h41mfp40.png" alt="image"></p>
<p>一张线程状态转换图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.54yn73xdwn80.png" alt="image"></p>
<h3 id="volatile指令重排序，内存屏障："><a href="#volatile指令重排序，内存屏障：" class="headerlink" title="volatile指令重排序，内存屏障："></a><strong>volatile指令重排序，内存屏障</strong>：</h3><p>volatile 的主要作用有两点： 1.保证变量的内存可见性  2.禁止指令重排序</p>
<p><strong>可见性问题</strong></p>
<p>JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。</p>
<p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>JMM 的规定：<br>- 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
<ul>
<li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li>
<li>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</li>
<li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li>
</ul>
<p>有两种方案：<strong>加锁</strong> 和 <strong>使用 volatile 关键字</strong>。</p>
<p>使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong>CPU 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。</p>
<p>volatile 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 volatile 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p>
<p>接下来我们就聊聊一个比较底层的知识点：<code>总线嗅探机制</code>。</p>
<p>在现代计算机中，CPU 的速度是极高的，如果 CPU 需要存取数据时都直接与内存打交道，在存取过程中，CPU 将一直空闲，这是一种极大的浪费，所以，为了提高处理速度，CPU 不直接和内存进行通信，而是在 CPU 与内存之间加入很多寄存器，多级缓存，它们比内存的存取速度高得多，这样就解决了 CPU 运算速度和内存读取速度不一致问题。</p>
<p>由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而<strong>嗅探是实现缓存一致性的常见机制</strong>。</p>
<p><strong>嗅探机制工作原理</strong>：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。</p>
<p><strong>禁止指令重排序</strong></p>
<p><strong>什么是重排序？</strong></p>
<p>为了提高性能，在遵守 <code>as-if-serial</code> 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守。）的情况下，编译器和处理器常常会对指令做重排序。</p>
<p>一般重排序可以分为如下三种类型：</p>
<ul>
<li>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<blockquote>
<p>数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
</blockquote>
<p>从 Java 源代码到最终执行的指令序列，会分别经历下面三种重排序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zkunstudy/images-host@master/myblog/image.50y00z3azgo0.png" alt="image"></p>
<p>volatile 是如何禁止指令重排序：内存屏障指令</p>
<p>使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<p><code>内存屏障</code>是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。</p>
<p>总结：</p>
<ul>
<li>volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值；或者作为状态变量，如 flag = ture，实现轻量级同步。</li>
<li>volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。</li>
<li>volatile 只能作用于属性，我们用 volatile 修饰属性，这样编译器就不会对这个属性做指令重排序。</li>
<li>volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。</li>
<li>volatile 提供了 happens-before 保证，对 volatile 变量 V 的写入 happens-before 所有其他线程后续对 V 的读操作。</li>
<li>volatile 可以使纯赋值操作是原子的，如 <code>boolean flag = true; falg = false</code>。</li>
<li>volatile 可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>K</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://kunstudy.com/2021/08/19/%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/%E3%80%90%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%9702%E3%80%91/">https://kunstudy.com/2021/08/19/%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/%E3%80%90%E9%87%8D%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%9702%E3%80%91/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span></span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"># 学习总结</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/08/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B/">线程间通信实例</a>
            
            
            <a class="next" rel="next" href="/2021/08/19/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">redis数据结构</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© K |Email @2958253141@qq.com </span>
    </div>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <span id="busuanzi_container_site_pv">
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
</footer>
    </div>
</body>

</html>